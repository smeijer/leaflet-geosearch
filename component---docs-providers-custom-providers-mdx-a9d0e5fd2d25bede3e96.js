(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{C5hP:function(e,t,r){"use strict";r.r(t),r.d(t,"_frontmatter",(function(){return p})),r.d(t,"default",(function(){return d}));var n=r("Fcif"),o=r("+I+c"),a=(r("mXGw"),r("/FXl")),s=r("TjRS"),i=(r("aD51"),["components"]),p={};void 0!==p&&p&&p===Object(p)&&Object.isExtensible(p)&&!Object.prototype.hasOwnProperty.call(p,"__filemeta")&&Object.defineProperty(p,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/providers/custom-providers.mdx"}});var c={_frontmatter:p},l=s.a;function d(e){var t=e.components,r=Object(o.a)(e,i);return Object(a.b)(l,Object(n.a)({},c,r,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"custom-providers"},"Custom Providers"),Object(a.b)("p",null,"It's possible to create your own providers either by creating one from scratch, or extending an existing one."),Object(a.b)("p",null,"The most trivial one to extend, is the ",Object(a.b)("a",{parentName:"p",href:"/providers/openstreetmap"},"OpenStreetMap")," provider. As Nominatim is open source, and can be self hosted, the provider allows for easy extension."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-js"},"import { OpenStreetMapProvider } from 'leaflet-geosearch';\n\nclass MyProvider extends OpenStreetMapProvider {\n  constructor(options) {\n    super({\n      ...options,\n      searchUrl: 'https://example.com/api/search',\n      reverseUrl: 'https://example.com/api/reverse',\n    });\n  }\n}\n")),Object(a.b)("p",null,"When the constructor is the only thing you need to override, it might be sufficient to provide the options during initialization:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-js"},"const provider = new OpenStreetMapProvider({\n  searchUrl: 'https://example.com/api/search',\n  reverseUrl: 'https://example.com/api/reverse',\n});\n")),Object(a.b)("p",null,"However, custom providers can be easier to share, and have a single source of truth. As you don't need to manage the URL's on various places throughout your codebase."),Object(a.b)("h2",{id:"custom-server-response"},"Custom Server Response"),Object(a.b)("p",null,"When you need to adjust the provider to support a different json data shape, you might want to override more than just the urls."),Object(a.b)("p",null,"The",Object(a.b)("inlineCode",{parentName:"p"},"parse")," method allows you to transform the server response, to the SearchResult types."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"endpoint")," method is there to select the correct endpoint, based on the search parameters."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-js"},"import { JsonProvider } from 'leaflet-geosearch';\n\nclass MyProvider extends JsonProvider {\n  endpoint({ query, type }) {\n    // Result: https://example.com/api/search?q=some%20address&f=json\n    return this.getUrl('https://example.com/api/search', {\n      q: query,\n      f: 'json',\n    });\n  }\n\n  parse({ data }) {\n    // Note that `data` is the raw result returned by the server. This\n    // method should return data in the SearchResult format.\n    return data.map((x) => ({\n      x: data.x,\n      y: data.y,\n      label: data.label,\n      bounds: data.bounds,\n    }));\n  }\n}\n")),Object(a.b)("h2",{id:"sharing"},"Sharing"),Object(a.b)("p",null,"When you've build a custom provider that can be used by others, please consider opening a ",Object(a.b)("a",{parentName:"p",href:"https://github.com/smeijer/leaflet-geosearch"},"pull-request"),", or publishing it to ",Object(a.b)("inlineCode",{parentName:"p"},"npm"),"."))}void 0!==d&&d&&d===Object(d)&&Object.isExtensible(d)&&!Object.prototype.hasOwnProperty.call(d,"__filemeta")&&Object.defineProperty(d,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/providers/custom-providers.mdx"}}),d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---docs-providers-custom-providers-mdx-a9d0e5fd2d25bede3e96.js.map