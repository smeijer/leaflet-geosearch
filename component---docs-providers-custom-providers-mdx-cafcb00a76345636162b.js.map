{"version":3,"sources":["webpack:///../docs/providers/custom-providers.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"weAMO,IAAMA,EAAe,Q,qNAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,oBADR,oBAGA,sIACA,+DAA8C,mBAAGC,WAAW,KAAQ,CAChE,KAAQ,6BADkC,iBAA9C,2GAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,0SAcL,0JACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,0JAOL,+LACA,iBAAQ,CACN,GAAM,0BADR,0BAGA,yJACA,2BAAU,0BAAYA,WAAW,KAAvB,SAAV,mFACA,4BAAW,0BAAYA,WAAW,KAAvB,YAAX,oFACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,4lBAyBL,iBAAQ,CACN,GAAM,WADR,WAGA,kHAAiG,mBAAGA,WAAW,KAAQ,CACnH,KAAQ,iDADqF,gBAAjG,yBAEmD,0BAAYA,WAAW,KAAvB,OAFnD,W,mNAOJJ,EAAWK,gBAAiB","file":"component---docs-providers-custom-providers-mdx-cafcb00a76345636162b.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/smeijer/dev/leaflet-geosearch/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"custom-providers\"\n    }}>{`Custom Providers`}</h1>\n    <p>{`It's possible to create your own providers either by creating one from scratch, or extending an existing one.`}</p>\n    <p>{`The most trivial one to extend, is the `}<a parentName=\"p\" {...{\n        \"href\": \"/providers/openstreetmap\"\n      }}>{`OpenStreetMap`}</a>{` provider. As Nominatim is open source, and can be self hosted, the provider allows for easy extension.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { OpenStreetMapProvider } from 'leaflet-geosearch';\n\nclass MyProvider extends OpenStreetMapProvider {\n  constructor(options) {\n    super({\n      ...options,\n      searchUrl: 'https://example.com/api/search',\n      reverseUrl: 'https://example.com/api/reverse',\n    });\n  }\n}\n`}</code></pre>\n    <p>{`When the constructor is the only thing you need to override, it might be sufficient to provide the options during initialization:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const provider = new OpenStreetMapProvider({\n  searchUrl: 'https://example.com/api/search',\n  reverseUrl: 'https://example.com/api/reverse',\n});\n`}</code></pre>\n    <p>{`However, custom providers can be easier to share, and have a single source of truth. As you don't need to manage the URL's on various places throughout your codebase.`}</p>\n    <h2 {...{\n      \"id\": \"custom-server-response\"\n    }}>{`Custom Server Response`}</h2>\n    <p>{`When you need to adjust the provider to support a different json data shape, you might want to override more than just the urls.`}</p>\n    <p>{`The`}<inlineCode parentName=\"p\">{`parse`}</inlineCode>{` method allows you to transform the server response, to the SearchResult types.`}</p>\n    <p>{`The `}<inlineCode parentName=\"p\">{`endpoint`}</inlineCode>{` method is there to select the correct endpoint, based on the search parameters.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { JsonProvider } from 'leaflet-geosearch';\n\nclass MyProvider extends JsonProvider {\n  endpoint({ query, type }) {\n    // Result: https://example.com/api/search?q=some%20address&f=json\n    return this.getUrl('https://example.com/api/search', {\n      q: query,\n      f: 'json',\n    });\n  }\n\n  parse({ data }) {\n    // Note that \\`data\\` is the raw result returned by the server. This\n    // method should return data in the SearchResult format.\n    return data.map(x => ({\n      x: data.x,\n      y: data.y,\n      label: data.label,\n      bounds: data.bounds,\n    }));\n  }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"sharing\"\n    }}>{`Sharing`}</h2>\n    <p>{`When you've build a custom provider that can be used by others, please consider opening a `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/smeijer/leaflet-geosearch\"\n      }}>{`pull-request`}</a>{`, or publishing it to `}<inlineCode parentName=\"p\">{`npm`}</inlineCode>{`.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}